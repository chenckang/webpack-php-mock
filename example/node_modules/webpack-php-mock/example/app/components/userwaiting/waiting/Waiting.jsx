import React from 'react';
import 'js/map/Mapv.js';
import './Waiting.less';

class WaitingMap extends React.Component {
    constructor(props) {
        super(props);
    }

    componentDidMount() {
        var map = new BMap.Map(this.refs.map.getDOMNode(), {
            enableMapClick: false
        });
        map.centerAndZoom(new BMap.Point(116.404, 39.915), 11);
        map.addControl(new BMap.MapTypeControl());
        map.enableScrollWheelZoom();
        map.setCurrentCity("北京");
        map.addControl(new BMap.NavigationControl());
        map.addControl(new BMap.ScaleControl());

        this.map = map;
        this.mapv = new Mapv({map: map});

        this.mapv.Scale.show();

    }

    componentWillUnmount() {
        this.hideScale()
    }

    render() {
        return (
            <div className="waiting">
                <div className="map" ref="map">
                </div>
            </div>
        );
    }

    renderMap(data) {
        var me = this;
        me.clear();
        if (!data) {
            return;
        }
        me.drawRegion(data);
        me.drawCast(data);
        me.resetViewport();
    }

    drawCast(data) {
        var detail = data.detail;
        var points = [];
        var max = 0;
        var mode;
        var ext;

        if (!detail) {
            return;
        }

        detail.forEach(function (item, idx) {
            var geo = [];
            var wt = 0;
            var attr = 'avg_wait_time';
            var divd = 60;
            var geo = [];
            var point = {};
            var count = 0;

            geo.push([item.trPoint[0], item.trPoint[1]]);
            geo.push([item.blPoint[0], item.trPoint[1]]);
            geo.push([item.blPoint[0], item.blPoint[1]]);
            geo.push([item.trPoint[0], item.blPoint[1]]);

            if ('weekday' === mode) {
                wt = item.weeks.weekday;
            }
            else {
                wt = item.weeks.weekend;
            }

            if ('sample' === ext) {
                attr = 'sample_number';
                divd = 1;
            }

            if (wt) {
                count = wt[attr] / divd;
                point.geo = geo;
                point.count = count.toFixed(0);
                points.push(point);

                max = max < count ? count : max;
            }
        });

        this.drawPointsWithMapv(points, ext, max);
    }

    drawPointsWithMapv(points, type, max) {
        var max = 'sample' === type ? 200 : 8;

        var layer = new Mapv.Layer({
            mapv: this.mapv, // 对应的mapv
            zIndex: 1, // 图层层级
            dataType: 'polygon', // 数据类型，点类型
            data: points, // 数据
            drawType: 'intensity', // 展示形式
            drawOptions: { // 绘制参数
                max: max,
                opacity: '0.5',
                label: { 
                    show: true,// 是否显示文字标签
                    font: "11px", // 设置字号
                    minZoom: 15, // 最小显示的级别
                    fillStyle: 'rgba(255, 255, 255, 1)' // label颜色
                },
                gradient: { // 显示的颜色渐变范围
                    '0': 'blue',
                    '0.6': 'cyan',
                    '0.7': 'lime',
                    '0.8': 'yellow',
                    '1.0': 'red'
                }
            }
        });
    }

    drawRegion(data) {
        var region = [];
        var coords = data.coords;

        if (!coords) {
            return;
        }

        coords.forEach(function (item, idx) {
            region.push(new BMap.Point(item.longitude, item.latitude));
        });

        this.drawPolygon(region);
    }

    drawPolygon(coords) {
        var me = this;
        var polygon = me.getPolygon(coords, {
            strokeColor: '#aaa',
            fillColor: '#bbb',
            strokeWeight: 2,
            strokeOpacity: 1,
            fillOpacity: 0.4,
            enableClicking: true
        });
        me.regionLayer = polygon;
        me.coords = coords;

        me.map.addOverlay(polygon);
    }

    resetViewport() {
        var me = this;
        // 解决地图视图置换中断问题
        setTimeout(function () {
            me.map.setViewport(me.coords);
        }, 0);
    }

    getPolygon(points, opt) {
        var polygon = new BMap.Polygon(points,
            {
                strokeColor: this.exist(opt, 'strokeColor', '#0B71F5'),
                fillColor: this.exist(opt, 'fillColor', '#0B71F5'),
                strokeWeight: this.exist(opt, 'strokeWeight', 2),
                strokeOpacity: this.exist(opt, 'strokeOpacity', 1),
                fillOpacity: this.exist(opt, 'fillOpacity', 0.3),
                enableClicking: this.exist(opt, 'enableClicking', true)
            });
        return polygon;
    }

    exist(opt, key, value) {
        return opt ? opt[key] ? opt[key] : value : value;
    }

    clear() {
        this.clearRegion();
        this.map.clearOverlays();
    }

    clearPoints() {
        var me = this;
        me.map.removeOverlay(me.pointsLayer);
        me.points = null;
        me.pointsLayer = null;
    }

    clearRegion() {
        var me = this;
        me.map.removeOverlay(me.regionLayer);
        me.coords = null;
        me.regionLayer = null;
    }

    showScale() {
        this.mapv.Scale.show();
    }

    hideScale() {
        this.mapv.Scale.hide();
    }
}

export default WaitingMap;