import React from 'react';
import toastr from 'toastr';
import 'toastr/toastr.less';
import shopImg from 'imgs/marker_shop.png';
import ShopCubes from './shopcubes/ShopCubes';
import './Areas.less';

var template = require('./crossinfo.tpl');

class Areas extends React.Component {
    constructor(props) {
        super(props);
    }

    componentDidMount() {
        var map = new BMap.Map(this.refs.map.getDOMNode(), {
            enableMapClick: false
        });

        this.map = this.initMap(map);
    }

    initMap(map) {
        map.centerAndZoom(new BMap.Point(116.404, 39.915), 11);
        map.addControl(new BMap.MapTypeControl());
        map.enableScrollWheelZoom();
        map.setCurrentCity("北京");
        map.addControl(new BMap.NavigationControl());
        map.addControl(new BMap.ScaleControl());

        this.cubes = new ShopCubes();
        map.addControl(this.cubes);
        this.cubes.clickShop(this.clickShop);

        return map;
    }

    render() {
        return (
            <div className="areas">
                <div className="map" ref="map">
                </div>
            </div>
        );
    }

    renderMap(data) {
        this.clear();
        this.overlap = data.overlap_num;
        this.shops = data.shop;
        this.drawAois(data.aoi_range);
        this.drawShops(data);
        this.resetViewport();
    }

    renderLargeMap(data) {
        this.clear();
        this.drawAois(data.map_coords);
        this.renderShopRanges(data);
        this.renderShop(data);
        this.resetViewport();
    }

    clickShop = (sid) => {
        for (var i in this.shopMarks) {
            if (this.shopMarks.hasOwnProperty(i)) {
                this.shopMarks[i].setAnimation(null);
            }
        }

        if (this.lastSid === sid) {
            this.lastSid = null;
            return;
        }

        this.shopMarks[sid] && this.shopMarks[sid].setAnimation(BMAP_ANIMATION_BOUNCE);
        this.lastSid = sid;
    }

    toggleShop = (evt) => {
        var $target = $(evt.target);
        var sid = $target.data('sid');
        if (sid) {
            var hide = this.shopHides[sid];
            if (hide) {
                this.showShop(sid);
                this.doCross(sid);
                $target.removeClass('shop-hide')
            }
            else {
                this.hideShop(sid);
                this.unCross(sid);
                $target.addClass('shop-hide')
            }
        }
    }

    showShop(sid) {
        var me = this;
        this.shopHides[sid] = false;
        this.map.addOverlay(this.shopMarks[sid]);
        this.shopRanges[sid].forEach(function (item, idx) {
            me.map.addOverlay(item);
        });
    }

    hideShop(sid) {
        var me = this;
        this.shopHides[sid] = true;
        this.map.removeOverlay(this.shopMarks[sid]);
        this.shopRanges[sid].forEach(function (item, idx) {
            me.map.removeOverlay(item);
        });
    }

    brandChange = (evt) => {
        var brand = evt.target.value;
        var aoiid = this.selectBox.getAoiid();
        this.draw(aoiid, brand);
    }

    resetViewport() {
        this.map.setViewport(this.resetArr);
    }

    showCrozz = (evt) => {
        var shopId = evt.target.shopId;

        shopId && this.renderCross(shopId);
    }

    renderCross(shopId) {
        var me = this;
        var crozz = [];

        for (var i in me.overlap) {
            if (me.overlap.hasOwnProperty(i)) {
                var lap = me.overlap[i];
                var toShop;
                var fromCount;
                var toCount;
                if (lap.shop_one === shopId) {
                    toShop = lap.shop_two;
                    fromCount = lap.count_one;
                    toCount = lap.count_two;
                }
                if (lap.shop_two === shopId) {
                    toShop = lap.shop_one;
                    fromCount = lap.count_two;
                    toCount = lap.count_one;
                }
                if (toShop) {
                    crozz.push({
                        fromShop: me.findShop(shopId)[0],
                        toShop: me.findShop(toShop)[0],
                        fromCount: fromCount,
                        toCount: toCount
                    });
                }
            }
        }

        me.paintCross(crozz);
    }

    addShopMarkHandler(marker, handler) {
        marker.addEventListener('click', handler);
        if (this.handlers[marker]) {
            this.handlers[marker].push(handler);
        }
        else {
            this.handlers[marker] = [handler];
        }
    }
    
    removeShopMarkHandler(marker) {
        var hs = this.handlers[marker];

        hs.forEach(function (item, idx) {
            marker.removeEventListener(item);
        });
    }

    midPosition(from, to) {
        var xBase = (from.lng + to.lng) / 2;
        var yBase = (from.lat + to.lat) / 2;

        return new BMap.Point(xBase, yBase);
    }

    showDetail(evt) {
        toastr.info(template.fetch({data: evt.target.itemMap}));
    }

    paintCross(crozz) {
        var me = this;

        function getColor(value) {
            return 'hsla('
                    + Math.max(0, (120 - value / 200 * 120))
                    + ', 80%, 50%, 0.8)';
        }

        for (var i in me.crozzSnippets) {
            if (me.crozzSnippets.hasOwnProperty(i)) {
                me.unCross(i);
            }
        }

        crozz && crozz.forEach(function (item, idx) {
            var fromShop = item.fromShop;
            var toShop = item.toShop;
            var fromPoint = new BMap.Point(fromShop.longitude, fromShop.latitude);
            var toPoint = new BMap.Point(toShop.longitude, toShop.latitude);
            var midPoint = new BMap.Point(
                (fromPoint.lng + toPoint.lng) / 2,
                (fromPoint.lat + toPoint.lat) / 2,
            );

            var count = Math.max(100, Math.min(400, +item.fromCount + +item.toCount));

            var fcurve = new BMapLib.CurveLine([fromPoint, midPoint], {
                strokeColor: getColor(+item.fromCount),
                strokeWeight: 8,
                strokeOpacity: 1
            });

            var tcurve = new BMapLib.CurveLine([midPoint, toPoint], {
                strokeColor: getColor(+item.toCount),
                strokeWeight: 8,
                strokeOpacity: 1
            });

            var circle = new BMap.Circle(midPoint, count, {
                strokeColor: '#fff',
                strokeWeight: 5,
                fillColor: getColor(count)
            });


            me.map.addOverlay(fcurve);
            me.map.addOverlay(tcurve);
            me.map.addOverlay(circle);
            circle.itemMap = item;

            circle.addEventListener('click', me.showDetail);

            if (me.crozzSnippets[fromShop.wid]) {
                me.crozzSnippets[fromShop.wid].push([fcurve, tcurve, circle])
            }
            else {
                me.crozzSnippets[fromShop.wid] = [[fcurve, tcurve, circle]];
            }

        });
    }

    doCross(fromShopId) {
        var me = this;
        var crosss = this.crozzSnippets[fromShopId];

        if (!crosss) {
            return;
        }

        for (var j = 0, l = crosss.length; j < l; j++) {
            crosss[j].forEach(function (item, idx){
                me.map.addOverlay(item);
            });
            var len = crosss[j].length;
            crosss[j][len - 1].addEventListener('click', this.showDetail);
        }
    }

    unCross(fromShopId) {
        var me = this;
        var crosss = this.crozzSnippets[fromShopId];

        if (!crosss) {
            return;
        }

        for (var j = 0, l = crosss.length; j < l; j++) {
            crosss[j].forEach(function (item, idx){
                me.map.removeOverlay(item);
            });
            var len = crosss[j].length;
            crosss[j][len - 1].removeEventListener('click', this.showDetail);
        }
    }

    findShop(shopid) {
        var shops = [];
        this.shops.forEach(function (item, idx, arr) {
            if (item.wid === shopid) {
                shops.push(item)
            }
        });
        return shops;
    }

    renderShop(data) {
        var loca = new BMap.Point(data.longitude, data.latitude);
        var shopMark = new BMap.Marker(loca);
        var iconSize = new BMap.Size(60, 76);
        var shopIcon = new BMap.Icon(shopImg, iconSize, {anchor: new BMap.Size(30, 76)});
        shopIcon.setImageSize(iconSize);
        shopMark.setIcon(shopIcon);
        this.shopCoord = loca;
        this.shopMarks[data.wid] = shopMark;
        shopMark.shopId = data.wid;
        this.addShopMarkHandler(shopMark, this.showCrozz)
        this.map.addOverlay(shopMark);
    }

    renderShopRanges(shop) {
        var me = this;
        var sid = shop.wid;

        shop.takeout_deliver_regions.forEach(function (im, ix) {
            var coords = [];
            im.forEach(function (i) {
                coords.push(new BMap.Point(i.longitude, i.latitude));
            });

            var polygon = me.drawRegion(coords, {
                strokeColor: shop.color,
                fillColor: shop.color,
                strokeWeight: 2,
                strokeOpacity: 1,
                fillOpacity: 0.4,
                enableClicking: true
            }, sid);

            if (me.shopRanges[sid]) {
                me.shopRanges[sid].push(polygon);
            }
            else {
                me.shopRanges[sid] = [polygon];
            }
        });
    }

    drawShops(data) {
        var me = this;
        var shops = data.shop;

        shops.forEach(function (shop, idx) {
            shop.total = shops.length || 1;
            shop.idx = (idx + 1) || 1;

            shop.color = 'hsla(' + 360 / shop.total * shop.idx + ', 60%, 70%, 0.8)';

            me.renderShopRanges(shop);
            me.renderShop(shop);
        });

        me.renderShopCubes(shops);
    }

    renderShopCubes(shops) {
        this.cubes.setShops(shops);
    }

    drawAois(data) {
        var coords = [];

        data.forEach(function (item, idx) {
            coords.push(new BMap.Point(item.longitude, item.latitude));
        });

        this.drawRegion(coords);
    }

    drawRegion(coords, opt, sid) {
        var me = this;
        opt = opt || {
            strokeColor: '#aaa',
            fillColor: '#bbb',
            strokeWeight: 1,
            strokeOpacity: 0.5,
            fillOpacity: 0.4,
            enableClicking: true
        };

        var polygon = me.getPolygon(coords, opt);

        me.map.addOverlay(polygon);
        me.resetArr = me.resetArr.concat(coords);

        return polygon;
    }

    clear() {
        this.resetArr = [];
        this.handlers = {};
        this.shopRanges = {};
        this.shopMarks = {};
        this.crozzSnippets = {};
        this.cubes.clear();
        this.map.clearOverlays();
    }

    getPolygon(points, opt) {
        var polygon = new BMap.Polygon(points,
            {
                strokeColor: this.exist(opt, 'strokeColor', '#0B71F5'),
                fillColor: this.exist(opt, 'fillColor', '#0B71F5'),
                strokeWeight: this.exist(opt, 'strokeWeight', 2),
                strokeOpacity: this.exist(opt, 'strokeOpacity', 1),
                fillOpacity: this.exist(opt, 'fillOpacity', 0.3),
                enableClicking: this.exist(opt, 'enableClicking', true)
            });
        return polygon;
    }

    exist(opt, key, value) {
        return opt ? opt[key] ? opt[key] : value : value;
    }
}

export default Areas;